"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreviousDialog = exports.DialogActor = exports.DialogParticipant = void 0;
const packets_pb_1 = require("../../../../proto/ai/inworld/packets/packets_pb");
var DialogParticipant;
(function (DialogParticipant) {
    DialogParticipant["UNKNOWN"] = "UNKNOWN";
    DialogParticipant["PLAYER"] = "PLAYER";
    DialogParticipant["CHARACTER"] = "CHARACTER";
})(DialogParticipant || (exports.DialogParticipant = DialogParticipant = {}));
class DialogActor {
    static toProto(talker) {
        switch (talker) {
            case DialogParticipant.PLAYER:
                return new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.PLAYER);
            case DialogParticipant.CHARACTER:
                return new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.AGENT);
            default:
                return new packets_pb_1.Actor().setType(packets_pb_1.Actor.Type.UNKNOWN);
        }
    }
    static fromProto(actor) {
        switch (actor.getType()) {
            case packets_pb_1.Actor.Type.PLAYER:
                return DialogParticipant.PLAYER;
            case packets_pb_1.Actor.Type.AGENT:
                return DialogParticipant.CHARACTER;
            default:
                return DialogParticipant.UNKNOWN;
        }
    }
}
exports.DialogActor = DialogActor;
class PreviousDialog {
    constructor(phrases) {
        this.phrases = phrases;
    }
    toProto() {
        const phrases = this.phrases.map((item) => new packets_pb_1.DialogHistory.HistoryItem()
            .setText(item.phrase)
            .setActor(DialogActor.toProto(item.talker)));
        return new packets_pb_1.DialogHistory().setHistoryList(phrases);
    }
    static fromProto(dialog) {
        return new PreviousDialog(dialog.getHistoryList().map((item) => ({
            talker: DialogActor.fromProto(item.getActor()),
            phrase: item.getText(),
        })));
    }
}
exports.PreviousDialog = PreviousDialog;
