"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InworldError = exports.ErrorResourceType = exports.ErrorReconnectionType = exports.ErrorType = void 0;
const status_pb_1 = require("../../../proto/ai/inworld/common/status_pb");
const node_grpc_error_details_1 = require("@stackpath/node-grpc-error-details");
var ErrorType;
(function (ErrorType) {
    ErrorType["SESSION_TOKEN_EXPIRED"] = "SESSION_TOKEN_EXPIRED";
    ErrorType["SESSION_TOKEN_INVALID"] = "SESSION_TOKEN_INVALID";
    ErrorType["SESSION_RESOURCES_EXHAUSTED"] = "SESSION_RESOURCES_EXHAUSTED";
    ErrorType["BILLING_TOKENS_EXHAUSTED"] = "BILLING_TOKENS_EXHAUSTED";
    ErrorType["ACCOUNT_DISABLED"] = "ACCOUNT_DISABLED";
    ErrorType["SESSION_INVALID"] = "SESSION_INVALID";
    ErrorType["RESOURCE_NOT_FOUND"] = "RESOURCE_NOT_FOUND";
    ErrorType["SAFETY_VIOLATION"] = "SAFETY_VIOLATION";
    ErrorType["SESSION_EXPIRED"] = "SESSION_EXPIRED";
    ErrorType["AUDIO_SESSION_EXPIRED"] = "AUDIO_SESSION_EXPIRED";
    ErrorType["SESSION_PAUSED"] = "SESSION_PAUSED";
})(ErrorType || (exports.ErrorType = ErrorType = {}));
var ErrorReconnectionType;
(function (ErrorReconnectionType) {
    ErrorReconnectionType["UNDEFINED"] = "UNDEFINED";
    ErrorReconnectionType["NO_RETRY"] = "NO_RETRY";
    ErrorReconnectionType["IMMEDIATE"] = "IMMEDIATE";
    ErrorReconnectionType["TIMEOUT"] = "TIMEOUT";
})(ErrorReconnectionType || (exports.ErrorReconnectionType = ErrorReconnectionType = {}));
var ErrorResourceType;
(function (ErrorResourceType) {
    ErrorResourceType["RESOURCE_TYPE_UNDEFINED"] = "RESOURCE_TYPE_UNDEFINED";
    ErrorResourceType["RESOURCE_TYPE_CONVERSATION"] = "RESOURCE_TYPE_CONVERSATION";
})(ErrorResourceType || (exports.ErrorResourceType = ErrorResourceType = {}));
const deserializeMap = {
    'ai.inworld.common.InworldStatus': status_pb_1.InworldStatus.deserializeBinary,
};
class InworldError {
    constructor(message, code, details) {
        this.details = [];
        this.message = message;
        this.code = code;
        this.details = details;
    }
    static fromProto(proto) {
        var _a, _b;
        const grpcErrorDetails = (0, node_grpc_error_details_1.deserializeGrpcStatusDetails)(proto, deserializeMap);
        let details;
        if (((_a = grpcErrorDetails === null || grpcErrorDetails === void 0 ? void 0 : grpcErrorDetails.details) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            details = (_b = grpcErrorDetails.details) === null || _b === void 0 ? void 0 : _b.map((d) => {
                var _a;
                const { errorType, maxRetries, reconnectType, resourceNotFound } = d.toObject();
                const { resourceId, resourceType } = resourceNotFound || {};
                return Object.assign({ errorType: this.getErrorType(errorType), reconnectTime: (_a = d.getReconnectTime()) === null || _a === void 0 ? void 0 : _a.toDate().toISOString(), reconnectType: this.getErrorReconnectionType(reconnectType), maxRetries: maxRetries }, ((resourceId || resourceType !== undefined) && {
                    resourceNotFound: Object.assign(Object.assign({}, (resourceId && { resourceId })), (resourceType !== undefined && {
                        resourceType: this.getErrorResourceType(resourceType),
                    })),
                }));
            });
        }
        return new InworldError(proto.message, proto.code, details);
    }
    static getErrorType(errorType) {
        switch (errorType) {
            case status_pb_1.ErrorType.SESSION_TOKEN_EXPIRED:
                return ErrorType.SESSION_TOKEN_EXPIRED;
            case status_pb_1.ErrorType.SESSION_TOKEN_INVALID:
                return ErrorType.SESSION_TOKEN_INVALID;
            case status_pb_1.ErrorType.SESSION_RESOURCES_EXHAUSTED:
                return ErrorType.SESSION_RESOURCES_EXHAUSTED;
            case status_pb_1.ErrorType.BILLING_TOKENS_EXHAUSTED:
                return ErrorType.BILLING_TOKENS_EXHAUSTED;
            case status_pb_1.ErrorType.ACCOUNT_DISABLED:
                return ErrorType.ACCOUNT_DISABLED;
            case status_pb_1.ErrorType.SESSION_INVALID:
                return ErrorType.SESSION_INVALID;
            case status_pb_1.ErrorType.RESOURCE_NOT_FOUND:
                return ErrorType.RESOURCE_NOT_FOUND;
            case status_pb_1.ErrorType.SAFETY_VIOLATION:
                return ErrorType.SAFETY_VIOLATION;
            case status_pb_1.ErrorType.SESSION_EXPIRED:
                return ErrorType.SESSION_EXPIRED;
            case status_pb_1.ErrorType.AUDIO_SESSION_EXPIRED:
                return ErrorType.AUDIO_SESSION_EXPIRED;
            case status_pb_1.ErrorType.SESSION_PAUSED:
                return ErrorType.SESSION_PAUSED;
            default:
                return undefined;
        }
    }
    static getErrorReconnectionType(reconnectType) {
        switch (reconnectType) {
            case status_pb_1.ReconnectionType.UNDEFINED:
                return ErrorReconnectionType.UNDEFINED;
            case status_pb_1.ReconnectionType.NO_RETRY:
                return ErrorReconnectionType.NO_RETRY;
            case status_pb_1.ReconnectionType.IMMEDIATE:
                return ErrorReconnectionType.IMMEDIATE;
            case status_pb_1.ReconnectionType.TIMEOUT:
                return ErrorReconnectionType.TIMEOUT;
            default:
                return undefined;
        }
    }
    static getErrorResourceType(resourceType) {
        switch (resourceType) {
            case status_pb_1.ResourceType.RESOURCE_TYPE_CONVERSATION:
                return ErrorResourceType.RESOURCE_TYPE_CONVERSATION;
            default:
                return ErrorResourceType.RESOURCE_TYPE_UNDEFINED;
        }
    }
}
exports.InworldError = InworldError;
