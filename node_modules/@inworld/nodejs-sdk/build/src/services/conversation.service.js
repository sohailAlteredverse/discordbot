"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationService = void 0;
const packets_pb_1 = require("../../../proto/ai/inworld/packets/packets_pb");
const uuid_1 = require("uuid");
const data_structures_1 = require("../common/data_structures");
const errors_1 = require("../common/errors");
const event_1 = require("../factories/event");
class ConversationService {
    constructor(connection, { participants, conversationId, addCharacters, }) {
        this.packetQueue = [];
        this.connection = connection;
        this.conversationId = conversationId !== null && conversationId !== void 0 ? conversationId : (0, uuid_1.v4)();
        this.participants = participants;
        this.addCharacters = addCharacters;
    }
    getConversationId() {
        return this.conversationId;
    }
    getCharacters() {
        return this.connection.getCharactersByResourceNames(this.participants);
    }
    changeParticipants(participants) {
        this.participants = participants;
    }
    updateParticipants(participants) {
        return __awaiter(this, void 0, void 0, function* () {
            const conversationId = this.getConversationId();
            const conversation = this.connection.conversations.get(conversationId);
            if (!conversation) {
                throw Error(`Conversation ${conversationId} not found`);
            }
            if (![data_structures_1.ConversationState.ACTIVE, data_structures_1.ConversationState.INACTIVE].includes(conversation.state)) {
                return;
            }
            this.connection.conversations.set(conversationId, {
                service: conversation.service,
                state: data_structures_1.ConversationState.PROCESSING,
            });
            // Load characters if they are not loaded
            let characters = yield this.connection.getCharactersList();
            const charactersToAdd = participants.filter((p) => !characters.find((c) => c.resourceName === p));
            if (charactersToAdd.length) {
                yield this.addCharacters(charactersToAdd);
            }
            characters = (yield this.connection.getCharactersList()).filter((c) => participants.includes(c.resourceName));
            // Update conversation
            const sent = yield this.connection.send(() => event_1.EventFactory.conversation(characters.map((character) => character.id), {
                conversationId: this.getConversationId(),
            }));
            yield this.resolveInterval(() => {
                const found = this.connection.conversations.get(sent.packetId.conversationId);
                return (found === null || found === void 0 ? void 0 : found.state) === data_structures_1.ConversationState.ACTIVE;
            }, () => {
                this.participants = participants;
                this.releaseQueue();
            });
            return sent;
        });
    }
    sendText(text) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => this.connection
                .getEventFactory()
                .text(text, { conversationId: this.getConversationId() }));
        });
    }
    sendAudio(chunk) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => this.connection
                .getEventFactory()
                .dataChunk(chunk, packets_pb_1.DataChunk.DataType.AUDIO, {
                conversationId: this.getConversationId(),
            }));
        });
    }
    sendTrigger(name, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => this.connection.getEventFactory().trigger(name, Object.assign(Object.assign({}, parameters), { conversationId: this.getConversationId() })));
        });
    }
    sendAudioSessionStart(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => this.connection.getEventFactory().audioSessionStart({
                mode: params === null || params === void 0 ? void 0 : params.mode,
                conversationId: this.getConversationId(),
            }));
        });
    }
    sendAudioSessionEnd() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => {
                return this.connection.getEventFactory().audioSessionEnd({
                    conversationId: this.getConversationId(),
                });
            });
        });
    }
    sendCancelResponse(cancelResponses) {
        return __awaiter(this, void 0, void 0, function* () {
            const characters = this.getCharacters();
            if (characters.length != 1) {
                return;
            }
            return this.ensureConversation(() => this.connection.getEventFactory().cancelResponse(Object.assign(Object.assign({}, cancelResponses), { character: characters[0] })));
        });
    }
    sendTTSPlaybackMute(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => {
                return this.connection.getEventFactory().mutePlayback(isMuted, {
                    conversationId: this.getConversationId(),
                });
            });
        });
    }
    sendNarratedAction(text) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.participants.length > 1) {
                throw Error(errors_1.MULTI_CHAR_NARRATED_ACTIONS);
            }
            return this.ensureConversation(() => this.connection.getEventFactory().narratedAction(text, {
                conversationId: this.getConversationId(),
            }));
        });
    }
    sendCustomPacket(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.ensureConversation(() => getPacket({
                conversationId: this.getConversationId(),
            }));
        });
    }
    ensureConversation(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            const conversationId = this.getConversationId();
            const conversation = this.connection.conversations.get(conversationId);
            if (!conversation) {
                throw Error(`Conversation ${conversationId} not found`);
            }
            if (conversation.state === data_structures_1.ConversationState.ACTIVE) {
                return this.connection.send(getPacket);
            }
            else if (conversation.state === data_structures_1.ConversationState.PROCESSING) {
                let packet;
                this.packetQueue.push({
                    getPacket,
                    afterWriting: (inworldPacket) => {
                        packet = inworldPacket;
                    },
                });
                return this.resolveInterval(() => !!packet, () => packet);
            }
            this.connection.conversations.set(this.getConversationId(), {
                service: conversation.service,
                state: data_structures_1.ConversationState.PROCESSING,
            });
            const conversationPacket = yield this.connection.send(() => event_1.EventFactory.conversation(conversation.service.getCharacters().map((c) => c.id), {
                conversationId: this.getConversationId(),
            }));
            yield this.resolveInterval(() => {
                const found = this.connection.conversations.get(conversationPacket.packetId.conversationId);
                return (found === null || found === void 0 ? void 0 : found.state) === data_structures_1.ConversationState.ACTIVE;
            });
            const sent = yield this.connection.send(getPacket);
            this.releaseQueue();
            return sent;
        });
    }
    resolveInterval(done, resolve) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((r) => {
                const interval = setInterval(() => {
                    if (done()) {
                        clearInterval(interval);
                        this.connection.removeInterval(interval);
                        r(resolve === null || resolve === void 0 ? void 0 : resolve());
                    }
                }, 10);
                this.connection.addInterval(interval);
            });
        });
    }
    releaseQueue() {
        this.packetQueue.forEach((item) => __awaiter(this, void 0, void 0, function* () {
            const inworldPacket = yield this.connection.send(item.getPacket);
            item.afterWriting(inworldPacket);
        }));
        this.packetQueue = [];
    }
}
exports.ConversationService = ConversationService;
