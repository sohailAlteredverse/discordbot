"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionService = void 0;
const timers_1 = require("timers");
const data_structures_1 = require("../common/data_structures");
const inworld_packet_entity_1 = require("../entities/inworld_packet.entity");
const scene_entity_1 = require("../entities/scene.entity");
const session_token_entity_1 = require("../entities/session_token.entity");
const event_1 = require("../factories/event");
const token_client_grpc_service_1 = require("./gprc/token_client_grpc.service");
const world_engine_client_grpc_service_1 = require("./gprc/world_engine_client_grpc.service");
class ConnectionService {
    constructor(props) {
        var _a;
        this.state = data_structures_1.ConnectionState.INACTIVE;
        this.eventFactory = new event_1.EventFactory();
        this.intervals = [];
        this.packetQueue = [];
        this.tokenService = new token_client_grpc_service_1.TokenClientGrpcService();
        this.engineService = new world_engine_client_grpc_service_1.WorldEngineClientGrpcService();
        this.connectionProps = props;
        this.onDisconnect = () => {
            var _a, _b;
            this.state = data_structures_1.ConnectionState.INACTIVE;
            (_b = (_a = this.connectionProps).onDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        this.onError =
            (_a = this.connectionProps.onError) !== null && _a !== void 0 ? _a : ((err) => console.error(err));
        if (this.connectionProps.onMessage) {
            this.onMessage = (packet) => __awaiter(this, void 0, void 0, function* () { return this.connectionProps.onMessage(this.convertPacketFromProto(packet)); });
        }
    }
    isActive() {
        return this.state === data_structures_1.ConnectionState.ACTIVE;
    }
    isAutoReconnected() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.connectionProps.config) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.autoReconnect) !== null && _c !== void 0 ? _c : true;
    }
    generateSessionToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const proto = yield this.tokenService.generateSessionToken(this.connectionProps.apiKey);
            return session_token_entity_1.SessionToken.fromProto(proto);
        });
    }
    openManually() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.isAutoReconnected()) {
                    throw Error('Impossible to open connection manually with `autoReconnect` enabled');
                }
                if (this.isActive()) {
                    throw Error('Connection is already open');
                }
                return this.open();
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    close() {
        var _a, _b;
        this.cancelScheduler();
        this.state = data_structures_1.ConnectionState.INACTIVE;
        if (this.connectionProps.onMessage) {
            (_a = this.stream) === null || _a === void 0 ? void 0 : _a.removeListener('data', this.onMessage);
        }
        (_b = this.stream) === null || _b === void 0 ? void 0 : _b.cancel();
        this.clearQueue();
    }
    getEventFactory() {
        return this.eventFactory;
    }
    getCharactersList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.scene) {
                yield this.loadScene();
            }
            return this.scene.characters;
        });
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.loadScene();
                if (this.state === data_structures_1.ConnectionState.LOADED) {
                    this.state = data_structures_1.ConnectionState.ACTIVATING;
                    this.stream = this.engineService.session(Object.assign({ sessionToken: this.sessionToken, onError: this.onError, onDisconnect: this.onDisconnect }, (this.onMessage && { onMessage: this.onMessage })));
                    this.state = data_structures_1.ConnectionState.ACTIVE;
                    this.releaseQueue();
                    this.scheduleDisconnect();
                }
            }
            catch (err) {
                this.onError(err);
                this.clearQueue();
            }
        });
    }
    send(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.cancelScheduler();
                if (!this.isActive() && !this.isAutoReconnected()) {
                    throw Error('Unable to send data due inactive connection');
                }
                return this.write(getPacket);
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    write(getPacket) {
        return __awaiter(this, void 0, void 0, function* () {
            let packet;
            const resolvePacket = () => new Promise((resolve) => {
                const done = (packet) => {
                    this.scheduleDisconnect();
                    resolve(this.convertPacketFromProto(packet));
                };
                if (packet) {
                    return done(packet);
                }
                const interval = setInterval(() => {
                    if (packet || this.state === data_structures_1.ConnectionState.INACTIVE) {
                        clearInterval(interval);
                        this.intervals = this.intervals.filter((i) => i !== interval);
                        done(packet);
                    }
                }, 10);
                this.intervals.push(interval);
            });
            if (this.isActive()) {
                packet = this.writeToStream(getPacket);
            }
            else {
                this.packetQueue.push({
                    getPacket,
                    afterWriting: (protoPacket) => {
                        packet = protoPacket;
                    },
                });
                yield this.open();
            }
            return resolvePacket();
        });
    }
    writeToStream(getPacket) {
        var _a;
        const packet = getPacket();
        (_a = this.stream) === null || _a === void 0 ? void 0 : _a.write(getPacket());
        return packet;
    }
    loadScene() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state === data_structures_1.ConnectionState.LOADING)
                return;
            let session;
            let changed = false;
            // Try to get session from provided storage
            if (this.connectionProps.sessionGetterSetter) {
                session = yield this.connectionProps.sessionGetterSetter.get();
            }
            try {
                const sessionToken = yield this.getOrLoadSessionToken(session === null || session === void 0 ? void 0 : session.sessionToken);
                changed = sessionToken !== this.sessionToken || changed;
                this.sessionToken = sessionToken;
                if (!this.scene) {
                    const scene = yield this.getOrLoadScene(session === null || session === void 0 ? void 0 : session.scene);
                    changed = scene !== this.scene || changed;
                    this.scene = scene;
                    if (!this.getEventFactory().getCurrentCharacter() &&
                        this.scene.characters.length) {
                        this.getEventFactory().setCurrentCharacter(this.scene.characters[0]);
                    }
                }
                // Try to save session token to provided storage
                if (changed) {
                    (_a = this.connectionProps.sessionGetterSetter) === null || _a === void 0 ? void 0 : _a.set({
                        sessionToken: this.sessionToken,
                        scene: this.scene,
                    });
                }
                if ([data_structures_1.ConnectionState.LOADING, data_structures_1.ConnectionState.INACTIVE].includes(this.state)) {
                    this.state = data_structures_1.ConnectionState.LOADED;
                }
            }
            catch (err) {
                this.onError(err);
            }
        });
    }
    getOrLoadSessionToken(savedSessionToken) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let sessionToken = savedSessionToken !== null && savedSessionToken !== void 0 ? savedSessionToken : this.sessionToken;
            const { sessionId } = sessionToken || {};
            // Generate new session token is it's empty or expired
            if (!sessionToken || session_token_entity_1.SessionToken.isExpired(sessionToken)) {
                this.state = data_structures_1.ConnectionState.LOADING;
                const generateSessionToken = (_a = this.connectionProps.generateSessionToken) !== null && _a !== void 0 ? _a : this.generateSessionToken.bind(this);
                sessionToken = yield generateSessionToken();
                // Reuse session id to keep context of previous conversation
                if (sessionId) {
                    sessionToken = new session_token_entity_1.SessionToken(Object.assign(Object.assign({}, sessionToken), { sessionId }));
                }
            }
            return sessionToken;
        });
    }
    getOrLoadScene(savedScene) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let scene = savedScene;
            // Load scene
            if (!scene) {
                const { client, name, user } = this.connectionProps;
                const proto = yield this.engineService.loadScene({
                    client,
                    name,
                    user,
                    capabilities: this.connectionProps.config.capabilities,
                    sessionToken: this.sessionToken,
                    setLoadSceneProps: (_a = this.connectionProps.extension) === null || _a === void 0 ? void 0 : _a.setLoadSceneProps,
                });
                scene = scene_entity_1.Scene.fromProto(proto);
            }
            return scene;
        });
    }
    scheduleDisconnect() {
        var _a, _b;
        if ((_b = (_a = this.connectionProps.config) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.disconnectTimeout) {
            this.cancelScheduler();
            this.disconnectTimeoutId = setTimeout(() => this.close(), this.connectionProps.config.connection.disconnectTimeout);
        }
    }
    cancelScheduler() {
        if (this.disconnectTimeoutId) {
            (0, timers_1.clearTimeout)(this.disconnectTimeoutId);
        }
    }
    releaseQueue() {
        this.packetQueue.forEach((item) => {
            var _a;
            const protoPacket = this.writeToStream(item.getPacket);
            (_a = item.afterWriting) === null || _a === void 0 ? void 0 : _a.call(item, protoPacket);
        });
        this.packetQueue = [];
    }
    clearQueue() {
        this.intervals.forEach((i) => {
            clearInterval(i);
        });
        this.intervals = [];
        this.packetQueue = [];
    }
    convertPacketFromProto(packet) {
        var _a;
        return ((_a = this.connectionProps.extension) === null || _a === void 0 ? void 0 : _a.convertPacketFromProto)
            ? this.connectionProps.extension.convertPacketFromProto(packet)
            : inworld_packet_entity_1.InworldPacket.fromProto(packet);
    }
}
exports.ConnectionService = ConnectionService;
